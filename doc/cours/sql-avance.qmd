---
title: "SQL avancé"
description: "[Slides](sql-avance-slides.html)"
author: "Ludovic Deneuville"
format: 
  html:
    toc: true
    toc-location: left
    toc-depth: 3
    number-sections: true
    number-depth: 2
  revealjs:
    theme: moon
    footer: "[Home](../../index.html) --- [SQL avancé](sql-avance.html)"
    slide-number: c/t                    # collapsed/total
    slide-level: 3
    controls: true
    output-file: sql-avance-slides.html
mermaid:
  theme: forest
code-line-numbers: false
from: markdown+emoji
---

:construction: WIP

## Données

```{.sql}
CREATE TABLE echecs.joueuse (
    id_joueuse     SERIAL         PRIMARY KEY,   
    nom            VARCHAR(50)    NOT NULL, 
    prenom         VARCHAR(50)    NOT NULL, 
    date_naissance TIMESTAMP,                 
    elo            INT            CHECK (elo > 0),  
    mail           VARCHAR(100)   UNIQUE,         
    est_arbitre    BOOLEAN        DEFAULT false,
    code_pays      VARCHAR(2),          
    taux_victoires FLOAT          CHECK (taux_victoires BETWEEN 0 AND 1)
);
```


## Sous-requête

### Dans un filtre

Vous souhaitez lister les joueuses avec un elo supérieur à la moyenne.

::: {.fragment}
```{.sql}
SELECT nom, 
       prenom,
       elo
FROM echecs.joueuse
WHERE elo >= (SELECT AVG(elo) 
                FROM echecs.joueuse);
```
:::

### Imbriquer les SELECT

```{.sql}
SELECT j.nom, 
       j.prenom, 
       j.elo,
       mec.max_elo_club
  FROM (SELECT id_club,
               MAX(elo) AS max_elo_club
          FROM joueuse
         GROUP BY id_club) mec
  JOIN joueuse j USING(id_club);
```

### EXISTS

Principe assez similaire au `IN`

```{.sql}
SELECT *
  FROM echecs.club c
 WHERE EXISTS (SELECT 1
                 FROM echecs.joueuse j
                WHERE c.id_club = j.id_joueuse
                  AND j.elo > 2400);
```

:::{.notes}
```{.sql}
SELECT *
  FROM echecs.club c
 WHERE c.id_club IN (SELECT j.id_joueuse
                       FROM echecs.joueuse j
                      WHERE j.elo > 2400);
```
:::

## Les vues

### Joueuses Françaises

Imaginons que nous avons de nombreuses requêtes à écrire sur les joueuses françaises ayant plus de 2000 elo.

Et nous n'avons pas envie de nous embetter à écrire à chaque fois toutes les restrictions.

### Nouvelle table

Solution 1 : créons une nouvelle table

```{.sql}
CREATE TABLE echecs.joueuse_fr_2000
AS
SELECT *
  FROM echecs.joueuse
 WHERE code_pays = 'FR'
   AND elo >= 2000
```

:::::: {.fragment}
::: {.callout-caution title="Problèmes"}
- Duplication des données
- Mise à jour
:::
::::::


### Common Table Expression

Pour une utilisation ponctuelle, vous pouvez utiliser une CTE. Le principe :

- Commencez par définir votre sous-requête *joueuses_fr_elo2000* avec `WITH`
- Appelez *joueuses_fr_elo2000* dans la requête principale

```{.sql}
WITH joueuses_fr_elo2000 
AS (SELECT *
      FROM joueuse
     WHERE code_pays = 'FR' 
       AND elo > 2000
)
SELECT nom, prenom, elo
  FROM joueuses_francaises_elo2000
 WHERE prenom LIKE 'A%';
```

:::{.notes}
Usage avancé

Comme une sous-requête
:::


### Table temporaire

N'existe que le temps de la session

```{.sql}
CREATE TEMPORARY TABLE joueuses_fr_elo2000 
AS
SELECT *
  FROM joueuse
 WHERE code_pays = 'FR' 
   AND elo > 2000;
```

### Vue

```{.sql}
CREATE VIEW joueuses_fr_elo2000 
AS
SELECT *
  FROM joueuse
 WHERE code_pays = 'FR' 
   AND elo > 2000;
```

### Avantages des vues

- Sauvegarde de requêtes complexes
  - jointures, filtres...
- Sécurité et Contrôle d'Accès
  - Masquer des colonnes sensibles

Par contre une vue n'est pas plus rapide, ni performante

### Vues matérialisées

Photo à un instant t

```{.sql}
CREATE MATERIALIZED VIEW joueuses_fr_elo2000 
AS
SELECT *
  FROM joueuse
 WHERE code_pays = 'FR' 
   AND elo > 2000;
```

## Gérer les droits

L'utilisateur qui crée une table peut distribuer des droits aux autres.

Voir section *priviléges* de la doc PostgreSQL

### Donner des droits

Lecture / écriture sur des tables

```{.sql}
-- Lecture pour tous
GRANT SELECT ON echecs.joueuse TO PUBLIC;

-- Tous les droits
GRANT ALL PRIVILEGES ON echecs.joueuse TO chantal WITH GRANT OPTION;
```

Suffixe `WITH GRANT OPTION` pour donner le droit de transmettre ce droit.

### Retirer des droits

```{.sql}
-- Lecture
REVOKE SELECT ON echecs.joueuse TO chantal;

-- Tous les droits
REVOKE ALL PRIVILEGES ON echecs.joueuse TO chantal;
```

Suffixe `CASCADE` pour retirer les droits à ceux qui ont reçu les droits de la part de...

### Rôle

Pour une gestion simplifiée des droits

```{.sql}
CREATE ROLE eleve;

GRANT SELECT, INSERT ON echecs.joueuse TO eleve;

GRANT eleve TO chantal;
```

### Droits sur un schéma

```{.sql}
GRANT USAGE ON SCHEMA echecs TO PUBLIC;

REVOKE CREATE ON SCHEMA echecs FROM chantal;

GRANT SELECT ON ALL TABLES IN SCHEMA echecs TO PUBLIC;
```

- CREATE : Autorise la création d'objets dans le schéma
- USAGE : Autorise uniquement l'accès au schéma (nécessaire pour utiliser les objets du schéma)


## Transactions

### Exemple

```{.sql}
BEGIN; -- Début de la transaction

UPDATE compte SET solde = solde - 100 WHERE id = 1;
UPDATE compte SET solde = solde + 100 WHERE id = 2;

COMMIT; -- Valider si ok
```

<br>

```{.sql}
ROLLBACK; -- en cas d'erreur
```

:::{.notes}
- Plusieurs utilisateurs peuvent faire des requêtes en même temps
- LOCK
- SAVEPOINT my_savepoint;
- ROLLBACK TO my_savepoint;
:::


### Propriétés ACID

Pour définir la fiabilité des transactions :

- **Atomicité** : Une transaction est "tout ou rien"
- **Cohérence** : La base reste dans un état valide avant et après la transaction
- **Isolation** : Les transactions concurrentes n'interfèrent pas entre elles
- **Durabilité** : Une transaction validée est enregistrée de manière permanente, même en cas de panne

:::{.notes}
- Soit toutes les opérations réussissent, soit elles sont annulées (rollback)
:::


## Divers

### Index

::: {.callout-note title="Définition"}
Un index est une structure de données qui améliore la vitesse des opérations de lecture sur une table en facilitant la recherche des données.

Il permet une lecture plus rapide sur une colonne utilisée fréquemment dans *WHERE*, *JOIN*, *GROUP BY*, *ORDER BY*
:::

```{.sql}
CREATE INDEX idx_nom_joueuse ON joueuse (nom);
```

:::{.notes}
- Recherche longue si beaucoup de lignes
- Système clé-valeur (index -> ligne)
:::


### Index + et -

- :heavy_check_mark: Haute cardinalité
- :heavy_check_mark: Peu de valeurs nulles
- :x: Créations, mises à jour
- :x: Prend de la place

:::{.notes}
- si Haute cardinalité : beaucoup de valeurs distinctes
- Si une colonne est souvent modifiée, l'index associé doit être mis à jour
- Index sous jacent sur colonnes UNIQUE (PK incluse)
:::


### Trigger

::: {.callout-note title="Définition"}
Un trigger est une fonction qui s'exécute automatiquement en réponse à une mise à jour d'une table

Il permet par exemple de :

- Garantir l'intégrité des données
- Implémenter des règles métier
- Synchroniser des données
:::

:::{.notes}
Peut se déclencher avant ou arpès une maj

Garantir l'intégrité des données : Valider ou corriger les données avant leur enregistrement.
Implémenter des règles métier : Empêcher des suppressions ou modifications non autorisées.
Synchroniser des données : Mettre à jour des tables liées automatiquement.
:::

